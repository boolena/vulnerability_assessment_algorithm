import gzip
import json
import numpy

import requests as requests
from io import BytesIO

import assets
import equals


NVD_CVE_URL = "https://nvd.nist.gov/feeds/json/cve/1.1/nvdcve-1.1-{year}.json.gz"
CPE_MATCH_FEED = "https://nvd.nist.gov/feeds/json/cpematch/1.0/nvdcpematch-1.0.json.gz"
cpe_feed_items = {}
vulnerable_assets = {"OR-Configurations": {"Hohe Zuverlässigkeit": {}, "Mittlere Zuverlässigkeit": {}, "Niedrige Zuverlässigkeit": {}}, "AND-Configurations": {"Hohe Zuverlässigkeit": {}, "Mittlere Zuverlässigkeit": {}, "Niedrige Zuverlässigkeit": {}}}



def analyse_run(cves, assets, check_or, check_and):

    global vulnerable_assets

    for cve in cves:

        cve_id = cve["cve"]["CVE_data_meta"]["ID"]

        for node in cve["configurations"]["nodes"]:
            if node["operator"] == "OR" and check_or:

                for match in node["cpe_match"]:
                    if not match["vulnerable"]:
                        continue

                    for ip_address in assets.keys():
                        vul_prod = is_any_product(match, assets[ip_address], cve_id)
                        if len(vul_prod) == 0:
                            continue
                        else:
                            for key in vul_prod.keys():
                                conf_key = ""
                                if vul_prod[key]["vul_type"] == 1 or vul_prod[key]["vul_type"] == 2:
                                    conf_key = "Hohe Zuverlässigkeit"
                                elif vul_prod[key]["vul_type"] == 3:
                                    conf_key = "Mittlere Zuverlässigkeit"
                                elif vul_prod[key]["vul_type"] == 4 or vul_prod[key]["vul_type"] == 5:
                                    conf_key = "Niedrige Zuverlässigkeit"
                                if vul_prod[key]["vul_type"] == 4:
                                    if "range_not_in_dictionary" not in vulnerable_assets["OR-Configurations"][conf_key]:
                                        vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"] = {}
                                    if ip_address not in vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"]:
                                        vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"][ip_address] = {}
                                    if key not in vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"][ip_address]:
                                        vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"][ip_address][key] = {}
                                    if cve_id not in vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"][ip_address][key]:
                                        vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"][ip_address][key][cve_id] = {}
                                    length = len(vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"][ip_address][key][cve_id].keys())
                                    vulnerable_assets["OR-Configurations"][conf_key]["range_not_in_dictionary"][ip_address][key][cve_id][length] = vul_prod[key]["vul_versions"]
                                else:
                                    if ip_address not in vulnerable_assets["OR-Configurations"][conf_key]:
                                        vulnerable_assets["OR-Configurations"][conf_key][ip_address] = {}
                                    if key not in vulnerable_assets["OR-Configurations"][conf_key][ip_address]:
                                        vulnerable_assets["OR-Configurations"][conf_key][ip_address][key] = []
                                    if cve_id not in vulnerable_assets["OR-Configurations"][conf_key][ip_address][key]:
                                        vulnerable_assets["OR-Configurations"][conf_key][ip_address][key].append(cve_id)

            elif node["operator"] == "AND" and check_and:

                for ip_address in assets.keys():

                    vul_types = []
                    vul_products = {}
                    child_counter = 0
                    not_any_in_child = False

                    if len(node["children"]) == 0:

                        vul_products = are_all_products(node["cpe_match"], assets[ip_address])
                        if len(vul_products) == 0:
                            continue
                        else:
                            vul_types = []
                            for key in vul_products.keys():
                                vul_types.append(vul_products[key]["vul_type"])
                            conf_key = ""
                            mean = numpy.mean(vul_types)
                            if mean <= 2:
                                conf_key = "Hohe Zuverlässigkeit"
                            elif mean <= 3.5:
                                conf_key = "Mittlere Zuverlässigkeit"
                            else:
                                conf_key = "Niedrige Zuverlässigkeit"
                            if ip_address not in vulnerable_assets["AND-Configurations"][conf_key]:
                                vulnerable_assets["AND-Configurations"][conf_key][ip_address] = {}
                            if cve_id not in vulnerable_assets["AND-Configurations"][conf_key][ip_address]:
                                vulnerable_assets["AND-Configurations"][conf_key][ip_address][cve_id] = []
                            vulnerable_assets["AND-Configurations"][conf_key][ip_address][cve_id].append(vul_products)

                    else:
                        for child in node["children"]:

                            child_vul_products = {}
                            for match in child["cpe_match"]:
                                if child_counter == 0 and not match["vulnerable"]:
                                    continue
                                else:
                                    match_vul_products = is_any_product(match, assets[ip_address], cve_id)
                                if len(match_vul_products) != 0:
                                    vul_types = []
                                    for key in match_vul_products.keys():
                                        child_vul_products[key] = match_vul_products[key]
                                        vul_types.append(match_vul_products[key]["vul_type"])
                            if len(child_vul_products) == 0:
                                not_any_in_child = True
                                break
                            else:
                                vul_products[child_counter] = child_vul_products
                                child_counter = child_counter + 1
                        if not_any_in_child:
                            continue
                        else:
                            conf_key = ""
                            if len(vul_types) == 0:
                                conf_key = "There is a problem with mean"
                                print(cve_id)
                            else:
                                mean = numpy.mean(vul_types)
                                if mean <= 2:
                                    conf_key = "Hohe Zuverlässigkeit"
                                elif mean <= 3.5:
                                    conf_key = "Mittlere Zuverlässigkeit"
                                else:
                                    conf_key = "Niedrige Zuverlässigkeit"
                            if ip_address not in vulnerable_assets["AND-Configurations"][conf_key]:
                                vulnerable_assets["AND-Configurations"][conf_key][ip_address] = {}
                            if cve_id not in vulnerable_assets["AND-Configurations"][conf_key][ip_address]:
                                vulnerable_assets["AND-Configurations"][conf_key][ip_address][cve_id] = []
                            vulnerable_assets["AND-Configurations"][conf_key][ip_address][cve_id].append(vul_products)


def are_all_products(cpe_match, products):

    vul_products = {}

    for match in cpe_match:
        is_any_prod = False
        vul_prod = ""
        vul_type = 0
        is_match_range = is_range(match)
        matches = {}
        if is_match_range:
            matches = get_node_from_feed(match)

        for product in products:

            if equals.cpe_disjoint(match["cpe23Uri"], product):
                continue

            if is_match_range:

                if len(matches) == 0:
                    result_equals = equals.cpe_equal_low(match["cpe23Uri"], product)
                    if result_equals:
                        is_any_prod = True
                        vul_prod = product
                        vul_type = 4
                        break

                elif len(matches) > 0:
                    is_any_match = False
                    for cpe in matches["cpe_name"]:
                        result_equals = equals.cpe_equal_high(cpe, product)
                        if result_equals:
                            vul_prod = product
                            vul_type = 1
                            is_any_match = True
                            break
                        result_equals = equals.cpe_superset(cpe, product)
                        if result_equals:
                            vul_prod = product
                            vul_type = 2
                            is_any_match = True
                            break
                        result_equals = equals.cpe_subset(cpe, product)
                        if result_equals:
                            vul_prod = product
                            vul_type = 3
                            is_any_match = True
                            break
                    if is_any_match:
                        is_any_prod = True

            else:
                result_equals = equals.cpe_equal_high(match["cpe23Uri"], product)
                if result_equals:
                    is_any_prod = True
                    vul_prod = product
                    vul_type = 1
                    break
                result_equals = equals.cpe_superset(match["cpe23Uri"], product)
                if result_equals:
                    is_any_prod = True
                    vul_prod = product
                    vul_type = 2
                    break
                result_equals = equals.cpe_subset(match["cpe23Uri"], product)
                if result_equals:
                    is_any_prod = True
                    vul_prod = product
                    vul_type = 3
                    break

        if not is_any_prod:
            vul_products = {}
            return vul_products
        else:
            vul_products[vul_prod] = {}
            vul_products[vul_prod]["vul_type"] = vul_type
            if is_match_range and len(matches) == 0:
                vul_products[vul_prod]["vul_versions"] = get_versions_keys(match)
    return vul_products


def is_any_product(cpe_match, products, cve_id):
    vul_products = {}
    matches = {}
    is_match_range = is_range(cpe_match)
    if is_match_range:
        matches = get_node_from_feed(cpe_match)

    is_any = False

    if len(matches) > 0 and is_match_range:
        for match in matches["cpe_name"]:
            for product in products:
                result_disjoint = equals.cpe_disjoint(match["cpe23Uri"], product)
                if result_disjoint:
                    continue
                result_equals = equals.cpe_equal_high(match["cpe23Uri"], product)
                if result_equals:
                    vul_products[product] = {}
                    vul_products[product]["vul_type"] = 1
                    is_any = True
                    continue
                result_equals = equals.cpe_superset(match["cpe23Uri"], product)
                if result_equals:
                    vul_products[product] = {}
                    vul_products[product]["vul_type"] = 2
                    is_any = True
                    continue
                result_equals = equals.cpe_subset(match["cpe23Uri"], product)
                if result_equals:
                    vul_products[product] = {}
                    vul_products[product]["vul_type"] = 3
                    is_any = True
                    continue
                else:
                    continue

    elif not is_match_range:
        for product in products:
            result_disjoint = equals.cpe_disjoint(cpe_match["cpe23Uri"], product)
            if result_disjoint:
                continue
            result_equals = equals.cpe_equal_high(cpe_match["cpe23Uri"], product)
            if result_equals:
                vul_products[product] = {}
                vul_products[product]["vul_type"] = 1
                is_any = True
                continue
            result_equals = equals.cpe_superset(cpe_match["cpe23Uri"], product)
            if result_equals:
                vul_products[product] = {}
                vul_products[product]["vul_type"] = 2
                is_any = True
                continue
            result_equals = equals.cpe_subset(cpe_match["cpe23Uri"], product)
            if result_equals:
                vul_products[product] = {}
                vul_products[product]["vul_type"] = 3
                is_any = True
                continue

    if (not is_any) or (len(matches) == 0 and is_match_range):
        for product in products:
            result_equals = equals.cpe_equal_low(cpe_match["cpe23Uri"], product)
            if result_equals:
                vul_products[product] = {}
                if len(matches) == 0 and is_match_range:
                    vul_products[product]["vul_type"] = 4
                    vul_products[product]["vul_versions"] = get_versions_keys(cpe_match)
                else:
                    vul_products[product]["vul_type"] = 5
            else:
                continue

    return vul_products


def is_range(match):
    is_match_range = False
    for key in match.keys():
        if key == "versionStartExcluding" or key == "versionStartIncluding" or key == "versionEndExcluding" or key == "versionEndIncluding":
            is_match_range = True
    return is_match_range


def get_versions_keys(cpe):
    versions = {}
    for key in cpe.keys():
        if key == "versionStartExcluding" or key == "versionStartIncluding" or key == "versionEndExcluding" or key == "versionEndIncluding":
            versions[key] = cpe[key]
    return versions


def get_node_from_feed(cpe_match_range):
    global cpe_feed_items
    for item in cpe_feed_items:
        is_in_item = True
        for key in cpe_match_range:
            if key == "vulnerable" or key == "cpe_name":
                continue
            if key not in item:
                is_in_item = False
                break
            if item[key] != cpe_match_range[key]:
                is_in_item = False
                break
        if is_in_item:
            return item
    empty_item = {}
    return empty_item


def get_cpe_matching_feed():
    resp = requests.get(CPE_MATCH_FEED).content
    raw = gzip.GzipFile(fileobj=BytesIO(resp)).read()
    del resp
    global cpe_feed_items
    cpe_feed_items = json.loads(raw.decode("utf-8"))["matches"]
    del raw


def run(assets, check_or, check_and):

    get_cpe_matching_feed()

    for year in range(2002, 2023):
        print("Checking {year}".format(year=year))
        # Download the file
        url = NVD_CVE_URL.format(year=year)
        resp = requests.get(url).content

        # Parse the XML elements
        raw = gzip.GzipFile(fileobj=BytesIO(resp)).read()
        del resp
        cve_items = json.loads(raw.decode("utf-8"))["CVE_Items"]
        del raw

        analyse_run(cve_items, assets, check_or, check_and)

    analyse_result_file = "vulnerable_assets.json"

    with open(analyse_result_file, "w") as m_result:
        json.dump(vulnerable_assets, m_result)


if __name__ == '__main__':

    # Warning: The runtimes are very high (up to several hours), since all data from the NVD are analyzed.
    # That is why the test data was separated.

    # Android 11, all configurations
    # run(assets.test_and_android, True, True)
    # Android 11, only "OR"-configurations
    # run(assets.test_or_android, True, False)
    # Android 11, only "AND"-configurations
    # run(assets.test_and_android, False, True)

    # Postgres 8.2.10, all configurations
    # run(assets.test_and_postgres, True, True)
    # Postgres 8.2.10, only "OR"-configurations
    # run(assets.test_or_postgres, True, False)
    # Postgres 8.2.10, only "AND"-configurations
    run(assets.test_and_postgres, False, True)

    # Airwave 8.0.11, all configurations
    # run(assets.test_or_airwave, True, True)
    # Airwave 8.0.11, only "OR"-configurations
    # run(assets.test_or_airwave, True, False)

    # Airwave Network Management, all configurations
    # run(assets.test_or_airwave_net, True, True)
    # Android 11, only "OR"-configurations
    # run(assets.test_or_airwave_net, True, False)

    # Full asset list, all configurations
    # run(assets.full_asset_list, True, True)
    # Full asset list, only "OR"-configurations
    # run(assets.full_asset_list, True, False)
    # Full asset list, only "AND"-configurations
    # run(assets.full_asset_list, False, True)
