def compare(source, target):
    if isinstance(source, str):
        source = source.lower()
    if isinstance(target, str):
        target = target.lower()
    # In this specification, unquoted wildcard characters in the target yield an undefined result.
    if isinstance(target, str) and contains_wildcards(target):
        return 'UNDEFINED'
    # If source and target attribute values are equal, then the result is EQUAL
    if source == target:
        return 'EQUAL'
    # If source attribute value is ANY, then the result is SUPERSET.
    if source == 'any':
        return 'SUPERSET'
    # If target attribute value is ANY, then the result is SUBSET.
    if target == 'any':
        return 'SUBSET'
    # If either source or target attribute value is NA then the result is DISJOINT
    if source == 'na' or target == 'na':
        return 'DISJOINT'
    return compare_strings(source, target)


def compare_strings(source, target):
    start = 0
    end = len(source)
    begins = 0
    ends = 0
    if source[0] == '*':
        start = 1
        begins = -1
    else:
        while start < len(source) and source[start] == '?':
            start = start + 1
            begins = begins + 1
    if source[end - 1] == '*' and is_even_wildcards(source, end - 1):
        end = end - 1
        ends = -1
    else:
        while end > 0 and source[end - 1] == '?' and is_even_wildcards(source, end - 1):
            end = end - 1
            ends = ends + 1
    source = source[start:end + 1]
    index = -1
    leftover = len(target)
    while leftover > 0:
        index = target.find(source, index + 1)
        if index == -1:
            break
        escapes = count_escape_characters(target, 0, index)
        if index > 0 and begins != -1 and begins < (index - escapes):
            break
        escapes = count_escape_characters(target, index + 1, len(target))
        leftover = len(target) - index - escapes - len(source)
        if leftover > 0 and ends != -1 and leftover > ends:
            continue
        # Eigene Erweiterung. Ohne dieser Bedingung gibt die Funktion für source = '8\\.2\\.1' und target = '8\\.2\\.10'
        # 'SUPERSET' zurück, was in diesem Fall falsch ist.
        if target[(index + len(source)):len(target)].isnumeric():
            break
        return 'SUPERSET'
    return 'DISJOINT'


def count_escape_characters(string, start, end):
    result = 0
    active = False
    i = 0
    while i < end:
        active = (not active) and (string[i] == '\\')
        if active and i >= start:
            result = result + 1
        i = i + 1
    return result


def is_even_wildcards(string, index):
    result = 0
    while index > 0 and string[index - 1] == '\\':
        index = index - 1
        result = result + 1
    return result % 2 == 0


def contains_wildcards(string):
    for index in range(0, len(string)):
        if string[index] == '*' or string[index] == '?':
            if index == 0 or string[index - 1] != '\\':
                return True
    return False


def unbind_fs(fs):
    result_wfn = {}
    counter = 2
    while counter < 13:
        v = get_comp_fs(fs, counter)
        v = unbind_value_fs(v)
        if counter == 2:
            result_wfn = set_wfn(result_wfn, "part", v)
        elif counter == 3:
            result_wfn = set_wfn(result_wfn, "vendor", v)
        elif counter == 4:
            result_wfn = set_wfn(result_wfn, "product", v)
        elif counter == 5:
            result_wfn = set_wfn(result_wfn, "version", v)
        elif counter == 6:
            result_wfn = set_wfn(result_wfn, "update", v)
        elif counter == 7:
            result_wfn = set_wfn(result_wfn, "edition", v)
        elif counter == 8:
            result_wfn = set_wfn(result_wfn, "language", v)
        elif counter == 9:
            result_wfn = set_wfn(result_wfn, "sw_edition", v)
        elif counter == 10:
            result_wfn = set_wfn(result_wfn, "target_sw", v)
        elif counter == 11:
            result_wfn = set_wfn(result_wfn, "target_hw", v)
        elif counter == 12:
            result_wfn = set_wfn(result_wfn, "other", v)
        counter = counter + 1
    return result_wfn


def unbind_value_fs(s):
    if s == "*":
        return 'ANY'
    elif s == "-":
        return 'NA'
    else:
        return add_quoting(s)


def add_quoting(s):
    result = ""
    idx = 0
    embedded = False
    while idx < len(s):
        if s[idx].isalnum() or s[idx] == "_":
            result = result + s[idx]
            idx = idx + 1
            embedded = True
            continue
        elif s[idx] == "\\":
            result = result + s[idx:idx + 1]
            idx = idx + 2
            embedded = True
            continue
        elif s[idx] == "*":
            if idx == 0 or idx == (len(s) - 1):
                result = result + s[idx]
                idx = idx + 1
                embedded = True
                continue
        elif s[idx] == "?":
            if (idx == 0 or idx == (len(s) - 1)) or (embedded and s[idx - 1] == "?") or (embedded and s[idx + 1] == "?"):
                result = result + s[idx]
                idx = idx + 1
                embedded = False
                continue
        else:
            result = result + "\\" + s[idx]
            idx = idx + 1
            embedded = True
    return result


def get_comp_fs(fs, i):
    uri_array = []
    if "\\:" in fs:
        start = 0
        end = 0
        ends = len(fs)
        while end < ends:
            if fs[end] == ":" and fs[end - 1] != "\\":
                uri_array.append(fs[start:end])
                start = end + 1
            end = end + 1
        if fs[ends - 1] == "*":
            uri_array.append("*")
    else:
        uri_array = fs.split(":")
    if i == 0:
        return "cpe"
    elif i == 1:
        return "2.3"
    elif i >= len(uri_array):
        return ""
    else:
        return uri_array[i]


def set_wfn(w, a, v):
    w[a] = v
    return w


